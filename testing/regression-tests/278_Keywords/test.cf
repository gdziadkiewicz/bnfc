-- Andreas, 2019-12-16
-- A grammar of keywords of the C, C++, Haskell, Java, Ocaml backends

-- Andreas, 2020-01-03: merge in testcase for issue #134

Prg. Program ::=
    Abstract
    And
    AndEq
    And_Eq
    As
    Asm
    Asr
    Assert
    Auto
    Begin
    Bitand
    Bitor
    Bool
    Boolean
    Break
    Byte
    Case
    Catch
    Char_
    Class
    Compl
    Const
    ConstCast
    Const_Cast
    Constraint
    Continue
    Data
    Default
    Delete
    Deriving
    Do
    Done
    Double_
    Downto
    DynamicCast
    Dynamic_Cast
    Else
    End
    Enum
    Exception
    Explicit
    Extends
    Extern
    External
    False
    Family
    Final
    Finally
    Float
    For
    Forall
    Foreign
    Friend
    Fun
    Function
    Functor
    Goto
    Hiding
    I               -- issue #134
    If
    Implements
    Import
    In
    Include
    Infix
    Infixl
    Infixr
    Inherit
    Initializer
    Inline
    Instance
    Instanceof
    Int
    Interface
    Land
    Lazy
    Let
    List
    Long
    Lor
    Lsl
    Lsr
    Lxor
    Match
    Mdo
    Method
    Mod
    Module
    Mutable
    Namespace
    Native
    New
    Newtype
    Nonrec
    Not
    NotEq
    Not_Eq
    Null
    Object
    Of
    Open
    Operator
    Or
    OrEq
    Or_Eq
    Package
    Pattern
    Private
    Proc
    Protected
    Public
    Qualified
    Rec
    Register
    ReinterpretCast
    Reinterpret_Cast
    Return
    Short
    Sig
    Signed
    Sizeof
    StaticCast
    Static_Cast
    Strictfp
    String_
    Struct
    Super
    Switch
    Synchronized
    Template
    Then
    This
    Throw
    Throws
    To
    Transient
    True
    Try
    Type
    Typedef
    Typeid
    Typename
    Union
    Unsigned
    Using
    Val
    Virtual
    Void
    Volatile
    WcharT
    Wchar_T
    When
    Where
    While
    With
    Xor
    XorEq
    Xor_Eq
    ;

Abstract_Mk         .  Abstract             ::= "abstract"         ;
And_Mk              .  And                  ::= "and"              ;
AndEq_Mk            .  AndEq                ::= "and_eq"           ;
And_Eq_Mk           .  And_Eq               ::= "and_eq"           ;
As_Mk               .  As                   ::= "as"               ;
Asm_Mk              .  Asm                  ::= "asm"              ;
Asr_Mk              .  Asr                  ::= "asr"              ;
Assert_Mk           .  Assert               ::= "assert"           ;
Auto_Mk             .  Auto                 ::= "auto"             ;
Begin_Mk            .  Begin                ::= "begin"            ;
Bitand_Mk           .  Bitand               ::= "bitand"           ;
Bitor_Mk            .  Bitor                ::= "bitor"            ;
Bool_Mk             .  Bool                 ::= "bool"             ;
Boolean_Mk          .  Boolean              ::= "boolean"          ;
Break_Mk            .  Break                ::= "break"            ;
Byte_Mk             .  Byte                 ::= "byte"             ;
Case_Mk             .  Case                 ::= "case"             ;
Catch_Mk            .  Catch                ::= "catch"            ;
Char__Mk            .  Char_                ::= "char"             ;
Class_Mk            .  Class                ::= "class"            ;
Compl_Mk            .  Compl                ::= "compl"            ;
Const_Mk            .  Const                ::= "const"            ;
ConstCast_Mk        .  ConstCast            ::= "const_cast"       ;
Const_Cast_Mk       .  Const_Cast           ::= "const_cast"       ;
Constraint_Mk       .  Constraint           ::= "constraint"       ;
Continue_Mk         .  Continue             ::= "continue"         ;
Data_Mk             .  Data                 ::= "data"             ;
Default_Mk          .  Default              ::= "default"          ;
Delete_Mk           .  Delete               ::= "delete"           ;
Deriving_Mk         .  Deriving             ::= "deriving"         ;
Do_Mk               .  Do                   ::= "do"               ;
Done_Mk             .  Done                 ::= "done"             ;
Double__Mk          .  Double_              ::= "double"           ;
Downto_Mk           .  Downto               ::= "downto"           ;
DynamicCast_Mk      .  DynamicCast          ::= "dynamic_cast"     ;
Dynamic_Cast_Mk     .  Dynamic_Cast         ::= "dynamic_cast"     ;
Else_Mk             .  Else                 ::= "else"             ;
End_Mk              .  End                  ::= "end"              ;
Enum_Mk             .  Enum                 ::= "enum"             ;
Exception_Mk        .  Exception            ::= "exception"        ;
Explicit_Mk         .  Explicit             ::= "explicit"         ;
Extends_Mk          .  Extends              ::= "extends"          ;
Extern_Mk           .  Extern               ::= "extern"           ;
External_Mk         .  External             ::= "external"         ;
False_Mk            .  False                ::= "false"            ;
Family_Mk           .  Family               ::= "family"           ;
Final_Mk            .  Final                ::= "final"            ;
Finally_Mk          .  Finally              ::= "finally"          ;
Float_Mk            .  Float                ::= "float"            ;
For_Mk              .  For                  ::= "for"              ;
Forall_Mk           .  Forall               ::= "forall"           ;
Foreign_Mk          .  Foreign              ::= "foreign"          ;
Friend_Mk           .  Friend               ::= "friend"           ;
Fun_Mk              .  Fun                  ::= "fun"              ;
Function_Mk         .  Function             ::= "function"         ;
Functor_Mk          .  Functor              ::= "functor"          ;
Goto_Mk             .  Goto                 ::= "goto"             ;
Hiding_Mk           .  Hiding               ::= "hiding"           ;
I_Mk                .  I                    ::= "i"                ; -- issue #134
If_Mk               .  If                   ::= "if"               ;
Implements_Mk       .  Implements           ::= "implements"       ;
Import_Mk           .  Import               ::= "import"           ;
In_Mk               .  In                   ::= "in"               ;
Include_Mk          .  Include              ::= "include"          ;
Infix_Mk            .  Infix                ::= "infix"            ;
Infixl_Mk           .  Infixl               ::= "infixl"           ;
Infixr_Mk           .  Infixr               ::= "infixr"           ;
Inherit_Mk          .  Inherit              ::= "inherit"          ;
Initializer_Mk      .  Initializer          ::= "initializer"      ;
Inline_Mk           .  Inline               ::= "inline"           ;
Instance_Mk         .  Instance             ::= "instance"         ;
Instanceof_Mk       .  Instanceof           ::= "instanceof"       ;
Int_Mk              .  Int                  ::= "int"              ;
Interface_Mk        .  Interface            ::= "interface"        ;
Land_Mk             .  Land                 ::= "land"             ;
Lazy_Mk             .  Lazy                 ::= "lazy"             ;
Let_Mk              .  Let                  ::= "let"              ;
List_Mk             .  List                 ::= "list"             ;
Long_Mk             .  Long                 ::= "long"             ;
Lor_Mk              .  Lor                  ::= "lor"              ;
Lsl_Mk              .  Lsl                  ::= "lsl"              ;
Lsr_Mk              .  Lsr                  ::= "lsr"              ;
Lxor_Mk             .  Lxor                 ::= "lxor"             ;
Match_Mk            .  Match                ::= "match"            ;
Mdo_Mk              .  Mdo                  ::= "mdo"              ;
Method_Mk           .  Method               ::= "method"           ;
Mod_Mk              .  Mod                  ::= "mod"              ;
Module_Mk           .  Module               ::= "module"           ;
Mutable_Mk          .  Mutable              ::= "mutable"          ;
Namespace_Mk        .  Namespace            ::= "namespace"        ;
Native_Mk           .  Native               ::= "native"           ;
New_Mk              .  New                  ::= "new"              ;
Newtype_Mk          .  Newtype              ::= "newtype"          ;
Nonrec_Mk           .  Nonrec               ::= "nonrec"           ;
Not_Mk              .  Not                  ::= "not"              ;
NotEq_Mk            .  NotEq                ::= "not_eq"           ;
Not_Eq_Mk           .  Not_Eq               ::= "not_eq"           ;
Null_Mk             .  Null                 ::= "null"             ;
Object_Mk           .  Object               ::= "object"           ;
Of_Mk               .  Of                   ::= "of"               ;
Open_Mk             .  Open                 ::= "open"             ;
Operator_Mk         .  Operator             ::= "operator"         ;
Or_Mk               .  Or                   ::= "or"               ;
OrEq_Mk             .  OrEq                 ::= "or_eq"            ;
Or_Eq_Mk            .  Or_Eq                ::= "or_eq"            ;
Package_Mk          .  Package              ::= "package"          ;
Pattern_Mk          .  Pattern              ::= "pattern"          ;
Private_Mk          .  Private              ::= "private"          ;
Proc_Mk             .  Proc                 ::= "proc"             ;
Protected_Mk        .  Protected            ::= "protected"        ;
Public_Mk           .  Public               ::= "public"           ;
Qualified_Mk        .  Qualified            ::= "qualified"        ;
Rec_Mk              .  Rec                  ::= "rec"              ;
Register_Mk         .  Register             ::= "register"         ;
ReinterpretCast_Mk  .  ReinterpretCast      ::= "reinterpret_cast" ;
Reinterpret_Cast_Mk .  Reinterpret_Cast     ::= "reinterpret_cast" ;
Return_Mk           .  Return               ::= "return"           ;
Short_Mk            .  Short                ::= "short"            ;
Sig_Mk              .  Sig                  ::= "sig"              ;
Signed_Mk           .  Signed               ::= "signed"           ;
Sizeof_Mk           .  Sizeof               ::= "sizeof"           ;
StaticCast_Mk       .  StaticCast           ::= "static_cast"      ;
Static_Cast_Mk      .  Static_Cast          ::= "static_cast"      ;
Strictfp_Mk         .  Strictfp             ::= "strictfp"         ;
String__Mk          .  String_              ::= "string"           ;
Struct_Mk           .  Struct               ::= "struct"           ;
Super_Mk            .  Super                ::= "super"            ;
Switch_Mk           .  Switch               ::= "switch"           ;
Synchronized_Mk     .  Synchronized         ::= "synchronized"     ;
Template_Mk         .  Template             ::= "template"         ;
Then_Mk             .  Then                 ::= "then"             ;
This_Mk             .  This                 ::= "this"             ;
Throw_Mk            .  Throw                ::= "throw"            ;
Throws_Mk           .  Throws               ::= "throws"           ;
To_Mk               .  To                   ::= "to"               ;
Transient_Mk        .  Transient            ::= "transient"        ;
True_Mk             .  True                 ::= "true"             ;
Try_Mk              .  Try                  ::= "try"              ;
Type_Mk             .  Type                 ::= "type"             ;
Typedef_Mk          .  Typedef              ::= "typedef"          ;
Typeid_Mk           .  Typeid               ::= "typeid"           ;
Typename_Mk         .  Typename             ::= "typename"         ;
Union_Mk            .  Union                ::= "union"            ;
Unsigned_Mk         .  Unsigned             ::= "unsigned"         ;
Using_Mk            .  Using                ::= "using"            ;
Val_Mk              .  Val                  ::= "val"              ;
Virtual_Mk          .  Virtual              ::= "virtual"          ;
Void_Mk             .  Void                 ::= "void"             ;
Volatile_Mk         .  Volatile             ::= "volatile"         ;
WcharT_Mk           .  WcharT               ::= "wchar_t"          ;
Wchar_T_Mk          .  Wchar_T              ::= "wchar_t"          ;
When_Mk             .  When                 ::= "when"             ;
Where_Mk            .  Where                ::= "where"            ;
While_Mk            .  While                ::= "while"            ;
With_Mk             .  With                 ::= "with"             ;
Xor_Mk              .  Xor                  ::= "xor"              ;
XorEq_Mk            .  XorEq                ::= "xor_eq"           ;
Xor_Eq_Mk           .  Xor_Eq               ::= "xor_eq"           ;

{-

-- The list of reserved words is the union of the reserved words of
-- the target languages (see below)

abstract
and
and_eq
as
asm
asr
assert
auto
begin
bitand
bitor
bool
boolean
break
byte
case
catch
char
class
compl
const
const_cast
constraint
continue
data
default
delete
deriving
do
done
double
downto
dynamic_cast
else
end
enum
exception
explicit
extends
extern
external
false
family
final
finally
float
for
forall
foreign
friend
fun
function
functor
goto
hiding
i
if
implements
import
in
include
infix
infixl
infixr
inherit
initializer
inline
instance
instanceof
int
interface
land
lazy
let
list
long
lor
lsl
lsr
lxor
match
mdo
method
mod
module
mutable
namespace
native
new
newtype
nonrec
not
not_eq
null
object
of
open
operator
or
or_eq
package
pattern
private
proc
protected
public
qualified
rec
register
reinterpret_cast
return
short
sig
signed
sizeof
static_cast
strictfp
string
struct
super
switch
synchronized
template
then
this
throw
throws
to
transient
true
try
type
typedef
typeid
typename
union
unsigned
using
val
virtual
void
volatile
wchar_t
when
where
while
with
xor
xor_eq

-- C reserved works

auto
break
case
char
const
continue
default
do
double
else
enum
extern
float
for
goto
if
int
long
register
return
short
signed
sizeof
static
struct
switch
typedef
union
unsigned
void
volatile
while

-- CPP reserved words (in addition to C's)

and
and_eq
asm
bitand
bitor
bool
catch
class
compl
const_cast
delete
dynamic_cast
explicit
false
friend
inline
mutable
namespace
new
not
not_eq
operator
or
or_eq
private
protected
public
reinterpret_cast
static_cast
template
this
throw
true
try
typeid
typename
using
virtual
wchar_t
xor
xor_eq

-- C#

string

-- Haskell reserved words

as
case
class
data
default
deriving
do
else
family
forall
foreign
hiding
if
import
in
infix
infixl
infixr
instance
let
mdo
module
newtype
of
pattern
proc
qualified
rec
then
type
where

-- Java reserved words

abstract
assert
boolean
break
byte
case
catch
char
class
const
continue
default
do
double
else
enum
extends
final
finally
float
for
goto
if
implements
import
instanceof
int
interface
long
native
new
package
private
protected
public
return
short
static
strictfp
super
switch
synchronized
this
throw
throws
transient
try
void
volatile
while

-- Ocaml reserved words

and
as
assert
asr
begin
class
constraint
do
done
downto
else
end
exception
external
false
for
fun
function
functor
if
in
include
inherit
initializer
land
lazy
let
list
lor
lsl
lsr
lxor
match
method
mod
module
mutable
new
nonrec
object
of
open
or
private
rec
sig
struct
then
to
true
try
type
val
virtual
when
while
with
-}




{-

-- Working material:

Abstract
And
AndEq
And_Eq
And_eq
As
Asm
Asr
Assert
Auto
Begin
Bitand
Bitor
Bool
Boolean
Break
Byte
Case
Catch
Char
Class
Compl
Const
ConstCast
Const_Cast
Const_cast
Constraint
Continue
Data
Default
Delete
Deriving
Do
Done
Double
Downto
DynamicCast
Dynamic_Cast
Dynamic_cast
Else
End
Enum
Exception
Explicit
Extends
Extern
External
False
Family
Final
Finally
Float
For
Forall
Foreign
Friend
Fun
Function
Functor
Goto
Hiding
If
Implements
Import
In
Include
Infix
Infixl
Infixr
Inherit
Initializer
Inline
Instance
Instanceof
Int
Interface
Land
Lazy
Let
List
Long
Lor
Lsl
Lsr
Lxor
Match
Mdo
Method
Mod
Module
Mutable
Namespace
Native
New
Newtype
Nonrec
Not
NotEq
Not_Eq
Not_eq
Object
Of
Open
Operator
Or
OrEq
Or_Eq
Or_eq
Package
Pattern
Private
Proc
Protected
Public
Qualified
Rec
Register
ReinterpretCast
Reinterpret_Cast
Reinterpret_cast
Return
Short
Sig
Signed
Sizeof
StaticCast
Static_Cast
Static_cast
Strictfp
String
Struct
Super
Switch
Synchronized
Template
Then
This
Throw
Throws
To
Transient
True
Try
Type
Typedef
Typeid
Typename
Union
Unsigned
Using
Val
Virtual
Void
Volatile
WcharT
Wchar_T
Wchar_t
When
Where
While
With
Xor
XorEq
Xor_Eq
Xor_eq


::= "abstract"         ;
::= "and"              ;
::= "and_eq"           ;
::= "and_eq"           ;
::= "and_eq"           ;
::= "as"               ;
::= "asm"              ;
::= "asr"              ;
::= "assert"           ;
::= "auto"             ;
::= "begin"            ;
::= "bitand"           ;
::= "bitor"            ;
::= "bool"             ;
::= "boolean"          ;
::= "break"            ;
::= "byte"             ;
::= "case"             ;
::= "catch"            ;
::= "char"             ;
::= "class"            ;
::= "compl"            ;
::= "const"            ;
::= "const_cast"       ;
::= "const_cast"       ;
::= "const_cast"       ;
::= "constraint"       ;
::= "continue"         ;
::= "data"             ;
::= "default"          ;
::= "delete"           ;
::= "deriving"         ;
::= "do"               ;
::= "done"             ;
::= "double"           ;
::= "downto"           ;
::= "dynamic_cast"     ;
::= "dynamic_cast"     ;
::= "dynamic_cast"     ;
::= "else"             ;
::= "end"              ;
::= "enum"             ;
::= "exception"        ;
::= "explicit"         ;
::= "extends"          ;
::= "extern"           ;
::= "external"         ;
::= "false"            ;
::= "family"           ;
::= "final"            ;
::= "finally"          ;
::= "float"            ;
::= "for"              ;
::= "forall"           ;
::= "foreign"          ;
::= "friend"           ;
::= "fun"              ;
::= "function"         ;
::= "functor"          ;
::= "goto"             ;
::= "hiding"           ;
::= "if"               ;
::= "implements"       ;
::= "import"           ;
::= "in"               ;
::= "include"          ;
::= "infix"            ;
::= "infixl"           ;
::= "infixr"           ;
::= "inherit"          ;
::= "initializer"      ;
::= "inline"           ;
::= "instance"         ;
::= "instanceof"       ;
::= "int"              ;
::= "interface"        ;
::= "land"             ;
::= "lazy"             ;
::= "let"              ;
::= "list"             ;
::= "long"             ;
::= "lor"              ;
::= "lsl"              ;
::= "lsr"              ;
::= "lxor"             ;
::= "match"            ;
::= "mdo"              ;
::= "method"           ;
::= "mod"              ;
::= "module"           ;
::= "mutable"          ;
::= "namespace"        ;
::= "native"           ;
::= "new"              ;
::= "newtype"          ;
::= "nonrec"           ;
::= "not"              ;
::= "not_eq"           ;
::= "not_eq"           ;
::= "not_eq"           ;
::= "object"           ;
::= "of"               ;
::= "open"             ;
::= "operator"         ;
::= "or"               ;
::= "or_eq"            ;
::= "or_eq"            ;
::= "or_eq"            ;
::= "package"          ;
::= "pattern"          ;
::= "private"          ;
::= "proc"             ;
::= "protected"        ;
::= "public"           ;
::= "qualified"        ;
::= "rec"              ;
::= "register"         ;
::= "reinterpret_cast" ;
::= "reinterpret_cast" ;
::= "reinterpret_cast" ;
::= "return"           ;
::= "short"            ;
::= "sig"              ;
::= "signed"           ;
::= "sizeof"           ;
::= "static_cast"      ;
::= "static_cast"      ;
::= "static_cast"      ;
::= "strictfp"         ;
::= "string"           ;
::= "struct"           ;
::= "super"            ;
::= "switch"           ;
::= "synchronized"     ;
::= "template"         ;
::= "then"             ;
::= "this"             ;
::= "throw"            ;
::= "throws"           ;
::= "to"               ;
::= "transient"        ;
::= "true"             ;
::= "try"              ;
::= "type"             ;
::= "typedef"          ;
::= "typeid"           ;
::= "typename"         ;
::= "union"            ;
::= "unsigned"         ;
::= "using"            ;
::= "val"              ;
::= "virtual"          ;
::= "void"             ;
::= "volatile"         ;
::= "wchar_t"          ;
::= "wchar_t"          ;
::= "wchar_t"          ;
::= "when"             ;
::= "where"            ;
::= "while"            ;
::= "with"             ;
::= "xor"              ;
::= "xor_eq"           ;
::= "xor_eq"           ;
::= "xor_eq"           ;

-}
