{-
    BNF Converter: Pretty-printer generator
    Copyright (C) 2016  Author:  Grzegorz Dziadkiewicz

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-}

-- based on BNFC OCaml backend

module BNFC.Backend.FSharp.CFtoFSharpPrinter (cf2Printer) where

import Data.Char(toLower)
import Data.List (intersperse, sortBy)
import Data.Maybe (fromJust)

import BNFC.CF
import BNFC.Utils
import BNFC.Backend.FSharp.FSharpUtil
import BNFC.PrettyPrint
import BNFC.Backend.Haskell.CFtoPrinter (compareRules)


-- derive pretty-printer from a BNF grammar. AR 15/2/2002
cf2Printer :: String -> String -> CF -> String
cf2Printer name absMod cf = unlines [
  prologue name absMod,
  charRule cf,
  integerRule cf,
  doubleRule cf,
  stringRule cf,
  if hasIdent cf then identRule cf else "",
  unlines [ownPrintRule cf own | (own,_) <- tokenPragmas cf],
  rules cf
  ]

prologue :: String -> String -> String
prologue name absMod = unlines [
  "// pretty-printer generated by the BNF converter",
  "module " ++ name,
  "",
  "open System",
  "open System.Text",
  "open " ++ absMod,
  "open Printf",
  "",
  "type Doc = StringBuilder -> int -> int",
  "",
  "let rec printTree (printer : int -> 'a -> Doc) (tree : 'a) : string = ",
  "    let initSize = 16",
  "    let buffer = StringBuilder initSize",
  "    printer 0 tree buffer 0 |> ignore",
  "    buffer.ToString()",
  "",
  "let indentWidth = 4",
  "",
  "let indent (i: int) : string = \"\\n\" + String.replicate i \" \"",
  "let append (s:string) (sb:StringBuilder) = sb.Append s",
  "",
  "// this render function is written for C-style languages, you may want to change it",
  "let render (s : string) : Doc = fun buf i -> ",
  "    let n = buf.Length",
  "    let last = if n = 0 then None else Some (buf.Chars (n-1))",
  "    let whitespace =",
  "        match last with",
  "        | None -> \"\" ",
  "        | Some '{' -> indent i",
  "        | Some '}' ->",
  "            match s with",
  "            | \";\" -> \"\"",
  "            | _ -> indent i",
  "        | Some ';' -> indent i",
  "        | Some '[' |  Some '(' -> \"\"",
  "        | Some _ ->",
  "            match s with",
  "            | \",\" | \")\" | \"]\" -> \"\"",
  "            | _ -> \" \"",
  "    let newindent =",
  "        match s with",
  "        | \"{\" -> i + indentWidth",
  "        | \"}\" -> i - indentWidth",
  "        | _ -> i",
  "    buf |> append whitespace |> append s |> ignore",
  "    newindent",
  "",
  "let emptyDoc : Doc = fun _ i -> i",
  "",
  "let concatD (ds : Doc list) : Doc = fun buf i -> ",
  "    List.fold (fun accIndent elemDoc -> elemDoc buf accIndent) (emptyDoc buf i) ds",
  "",
  "let parenth (d:Doc) : Doc = concatD [render \"(\"; d; render \")\"]",
  "",
  "let prPrec (i:int) (j:int) (d:Doc) : Doc = if j<i then parenth d else d",
  ""
  ]

charRule cf = unlines [
    "let rec prtchar (_:int) (c:char) : Doc = render (\"'\" + string c + \"'\")",
    ifList cf catChar
    ]

integerRule cf = unlines [
    "let rec prtint (_:int) (i:int) : Doc = render (string i)",
    ifList cf catInteger
    ]

doubleRule cf = unlines [
    "let rec prtfloat (_:int) (f:float) : Doc = render (sprintf \"%f\" f)",
    ifList cf catDouble
    ]

stringRule cf = unlines [
    "let rec prtString (_:int) (s:string) : Doc = render (\"\\\"\" + s + \"\\\"\")",
    ifList cf catString
    ]

identRule cf = ownPrintRule cf catIdent

ownPrintRule cf own = unlines [
  "let rec" +++ prtFun own +++ "_ (" ++ show own ++ posn ++ ") : Doc = render i",
  ifList cf own
  ]
 where
   posn = if isPositionCat cf own then " (_,i)" else " i"

-- copy and paste from CFtoTemplate

rules :: CF -> String
rules cf = unlines $ mutualDefs $
  map (\(s,xs) -> case_fun s (map toArgs xs) ++ ifList cf s) $ cf2data cf
 where
   reserved = "i":"e":reservedFSharp
   toArgs (cons,args) = ((cons, mkNames reserved LowerCase (map var args)), ruleOf cons)
   var (ListCat c)  = var c ++ "s"
   var (Cat "Ident")   = "id"
   var (Cat "Integer") = "n"
   var (Cat "String")  = "str"
   var (Cat "Char")    = "c"
   var (Cat "Double")  = "d"
   var xs        = map toLower (show xs)
   ruleOf s = fromJust $ lookupRule s (cfgRules cf)

--- case_fun :: Cat -> [(Constructor,Rule)] -> String
case_fun cat xs = unlines [
  prtFun cat +++"(i:int)" +++ "(e:" ++ fixType cat ++ ") : Doc =",
  "    match e with",
  unlines $ map (indent 1) $ insertBar $ map g xs
  ]
  where
    g ((c,xx),r) =
      c +++ mkTuple xx +++ "->" +++
      "prPrec i" +++ show (precCat (fst r)) +++ mkRhs xx (snd r)

-- ifList cf cat = mkListRule $ nil cat ++ one cat ++ cons cat where
--   nil cat  = ["    []    -> " ++ mkRhs [] its |
--                             Rule f c its <- rulesOfCF cf, isNilFun f , normCatOfList c == cat]
--   one cat  = ["  | [x]   -> " ++ mkRhs ["x"] its |
--                             Rule f c its <- rulesOfCF cf, isOneFun f , normCatOfList c == cat]
--   cons cat = ["  | x::xs -> " ++ mkRhs ["x","xs"] its |
--                             Rule f c its <- rulesOfCF cf, isConsFun f , normCatOfList c == cat]
--   mkListRule [] = ""
--   mkListRule rs = unlines $ ("and prt" ++ fixType cat ++ "ListBNFC" +++ "_ es : Doc = match es with"):rs

ifList :: CF -> Cat -> String
ifList cf cat = case cases of
    []        -> ""
    xs -> render $ vcat
        [ "and prt" <> text (fixType cat)  <> "ListBNFC i es : Doc ="
        , nest 4 "match (i, es) with"
        , nest 4 $ vcat (map ("|" <+>) xs)
        ]
  where
    rules = sortBy compareRules $ rulesForNormalizedCat cf (ListCat cat)
    cases = [ mkPrtListCase r | r <- rules ]


-- | Pattern match on the list constructor and the coercion level
-- >>> mkPrtListCase (Rule "[]" (ListCat (Cat "Foo")) [])
-- (_,[]) -> (concatD [])
-- >>> mkPrtListCase (Rule "(:[])" (ListCat (Cat "Foo")) [Left (Cat "Foo")])
-- (_,[x]) -> (concatD [prtFoo 0 x])
-- >>> mkPrtListCase (Rule "(:)" (ListCat (Cat "Foo")) [Left (Cat "Foo"), Left (ListCat (Cat "Foo"))])
-- (_,x::xs) -> (concatD [prtFoo 0 x ; prtFooListBNFC 0 xs])
-- >>> mkPrtListCase (Rule "[]" (ListCat (CoercCat "Foo" 2)) [])
-- (2,[]) -> (concatD [])
-- >>> mkPrtListCase (Rule "(:[])" (ListCat (CoercCat "Foo" 2)) [Left (CoercCat "Foo" 2)])
-- (2,[x]) -> (concatD [prtFoo 2 x])
-- >>> mkPrtListCase (Rule "(:)" (ListCat (CoercCat "Foo" 2)) [Left (CoercCat "Foo" 2), Left (ListCat (CoercCat "Foo" 2))])
-- (2,x::xs) -> (concatD [prtFoo 2 x ; prtFooListBNFC 2 xs])
mkPrtListCase :: Rule -> Doc
mkPrtListCase (Rule f (ListCat c) rhs)
  | isNilFun f  = parens (precPattern <> "," <> "[]") <+> "->" <+> body
  | isOneFun f  = parens (precPattern <> "," <> "[x]") <+> "->" <+> body
  | isConsFun f = parens (precPattern <> "," <>"x::xs") <+> "->" <+> body
  | otherwise = empty -- (++) constructor
  where
    precPattern = case precCat c of 0 -> "_" ; p -> integer p
    body = text $ mkRhs ["x", "xs"] rhs
mkPrtListCase _ = error "mkPrtListCase undefined for non-list categories"

mkRhs args its =
  "(concatD [" ++ unwords (intersperse ";" (mk args its)) ++ "])"
 where
  mk args (Left InternalCat : items)      = mk args items
  mk (arg:args) (Left c : items)  = (prt c +++ arg)        : mk args items
  mk args       (Right s : items) = ("render " ++ show s) : mk args items
  mk _ _ = []
  prt c = prtFun c +++ show (precCat c)

prtFun :: Cat -> String
prtFun (ListCat c) = prtFun c ++ "ListBNFC"
prtFun c = "prt" ++ fixType (normCat c)

